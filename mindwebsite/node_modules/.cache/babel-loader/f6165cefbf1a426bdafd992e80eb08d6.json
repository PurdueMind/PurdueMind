{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"/workspaces/PurdueMind.github.io/mindwebsite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"/workspaces/PurdueMind.github.io/mindwebsite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/workspaces/PurdueMind.github.io/mindwebsite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/workspaces/PurdueMind.github.io/mindwebsite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/workspaces/PurdueMind.github.io/mindwebsite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/workspaces/PurdueMind.github.io/mindwebsite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/workspaces/PurdueMind.github.io/mindwebsite/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _ms = _interopRequireDefault(require(\"ms\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _controls = require(\"./controls\");\n\nvar _areChildImagesEqual = _interopRequireDefault(require(\"./utils/areChildImagesEqual\"));\n\nvar _nth = _interopRequireDefault(require(\"./utils/nth\"));\n/* eslint\n  jsx-a11y/mouse-events-have-key-events: 0,\n  jsx-a11y/no-noninteractive-element-interactions: 0,\n  jsx-a11y/click-events-have-key-events: 0 */\n\n\nvar SELECTED_CLASS = 'carousel-slide-selected';\nvar LOADING_CLASS = 'carousel-slide-loading';\nvar MAX_LOAD_RETRIES = 500;\n/**\n * React component class that renders a carousel, which can contain images or other content.\n *\n * @extends React.Component\n */\n\nvar Carousel = /*#__PURE__*/function (_react$Component) {\n  _inherits(Carousel, _react$Component);\n\n  var _super = _createSuper(Carousel);\n\n  function Carousel(props) {\n    var _this;\n\n    _classCallCheck(this, Carousel);\n\n    _this = _super.apply(this, arguments);\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"handleInitialLoad\", function () {\n      var currentSlide = _this.state.currentSlide;\n      var slides = _this._track.childNodes;\n      var _this$props = _this.props,\n          slideWidth = _this$props.slideWidth,\n          slideHeight = _this$props.slideHeight;\n\n      if (!slideWidth || !slideHeight) {\n        for (var i = 0; i < slides.length; i++) {\n          var slide = slides[i];\n\n          if (parseInt(slide.getAttribute('data-index'), 10) === currentSlide) {\n            if (!slide.offsetWidth || !slide.offsetHeight) {\n              _this._initialLoadTimer = setTimeout(_this.handleInitialLoad, 10);\n              return;\n            }\n\n            _this.setState({\n              slideDimensions: {\n                width: slide.offsetWidth,\n                height: slide.offsetHeight\n              }\n            });\n\n            break;\n          }\n        }\n      }\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"goToSlide\", function (index, direction) {\n      var autoSlide = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var _this$props2 = _this.props,\n          beforeChange = _this$props2.beforeChange,\n          transitionDuration = _this$props2.transitionDuration,\n          transition = _this$props2.transition,\n          onSlideTransitioned = _this$props2.onSlideTransitioned,\n          children = _this$props2.children;\n      var currentSlide = _this.state.currentSlide;\n      var lastIndex = _react.Children.count(children) - 1;\n      var newIndex = index < 0 ? lastIndex + index + 1 : index <= lastIndex ? index : index - lastIndex - 1;\n      direction = direction || (index > currentSlide ? 'right' : 'left');\n\n      if (onSlideTransitioned) {\n        onSlideTransitioned({\n          autoPlay: autoSlide,\n          index: newIndex,\n          direction: direction\n        });\n      }\n\n      if (currentSlide === newIndex) {\n        return;\n      }\n\n      if (_this._animating) {\n        return;\n      }\n\n      _this._animating = true;\n      beforeChange && beforeChange(newIndex, currentSlide, direction);\n\n      _this.setState({\n        transitionDuration: transitionDuration\n      }, function () {\n        _this.setState({\n          currentSlide: newIndex,\n          direction: direction,\n          transitioningFrom: currentSlide\n        }, function () {\n          if (!transitionDuration || transition === 'fade') {\n            // We don't actually animate if transitionDuration is 0, so immediately call the transition end callback\n            _this.slideTransitionEnd();\n          }\n        });\n      });\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"nextSlide\", function (e) {\n      var currentSlide = _this.state.currentSlide;\n\n      _this.goToSlide(currentSlide + 1, 'right', typeof e !== 'object');\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"prevSlide\", function () {\n      var currentSlide = _this.state.currentSlide;\n\n      _this.goToSlide(currentSlide - 1, 'left');\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"slideTransitionEnd\", function (e) {\n      var currentSlide = _this.state.currentSlide;\n      var afterChange = _this.props.afterChange;\n\n      if (!e || e.propertyName === 'transform') {\n        _this._animating = false;\n\n        _this.setState({\n          direction: null,\n          transitioningFrom: null,\n          transitionDuration: 0\n        }, function () {\n          if (!_this._allImagesLoaded) {\n            _this.fetchImages();\n          }\n        });\n\n        if (_this.props.autoplay) {\n          _this.startAutoplay();\n        }\n\n        afterChange && afterChange(currentSlide);\n      }\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"calcLeftOffset\", function () {\n      var retryCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var _this$state = _this.state,\n          direction = _this$state.direction,\n          loading = _this$state.loading;\n      var viewportWidth = _this._viewport && _this._viewport.offsetWidth;\n      clearTimeout(_this._retryTimer);\n\n      if (!_this._track || !viewportWidth) {\n        _this._retryTimer = setTimeout(_this.calcLeftOffset, 10);\n        return;\n      }\n\n      var _this$props3 = _this.props,\n          infinite = _this$props3.infinite,\n          children = _this$props3.children,\n          cellPadding = _this$props3.cellPadding,\n          slideAlignment = _this$props3.slideAlignment;\n      var currentSlide = _this.state.currentSlide;\n      var slides = _this._track.childNodes;\n\n      var numChildren = _react.Children.count(children);\n\n      if (infinite) {\n        if (currentSlide === 0 && direction === 'right') {\n          currentSlide = numChildren;\n        } else if (currentSlide === numChildren - 1 && direction === 'left') {\n          currentSlide = -1;\n        }\n      }\n\n      var leftOffset = 0;\n      var selectedSlide;\n      var foundZeroWidthSlide = false;\n      var isCurrentSlideLoading = false;\n      var currentSlideWidth;\n\n      for (var i = 0; i < slides.length; i++) {\n        selectedSlide = slides[i];\n        leftOffset -= cellPadding;\n        isCurrentSlideLoading = selectedSlide.className.indexOf(LOADING_CLASS) !== -1;\n        currentSlideWidth = selectedSlide.offsetWidth;\n        foundZeroWidthSlide = foundZeroWidthSlide || !currentSlideWidth && !isCurrentSlideLoading;\n\n        if (parseInt(selectedSlide.getAttribute('data-index'), 10) === currentSlide) {\n          break;\n        }\n\n        leftOffset -= currentSlideWidth;\n      } // Adjust the offset to get the correct alignment of current slide within the viewport\n\n\n      if (slideAlignment === 'center') {\n        leftOffset += (viewportWidth - currentSlideWidth) / 2;\n      } else if (slideAlignment === 'right') {\n        leftOffset += viewportWidth - currentSlideWidth;\n      }\n\n      var shouldRetry = foundZeroWidthSlide && retryCount < MAX_LOAD_RETRIES;\n\n      if (leftOffset !== _this.state.leftOffset) {\n        _this.setState({\n          leftOffset: leftOffset\n        });\n      }\n\n      if (shouldRetry) {\n        _this._retryTimer = setTimeout(_this.calcLeftOffset.bind(_assertThisInitialized(_this), ++retryCount), 10);\n        return;\n      }\n\n      if (loading) {\n        // We have correctly positioned the slides and are done loading images, so reveal the carousel\n        _this.setState({\n          loading: false\n        });\n      }\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"handleSlideClick\", function (e) {\n      var clickToNavigate = _this.props.clickToNavigate;\n      var currentSlide = _this.state.currentSlide;\n      var clickedIndex = parseInt(e.currentTarget.getAttribute('data-index'), 10); // If the user clicked the current slide or it appears they are dragging, don't process the click\n\n      if (!clickToNavigate || clickedIndex === currentSlide || Math.abs(_this._startPos.x - e.clientX) > 0.01) {\n        return;\n      }\n\n      _this.goToSlide(clickedIndex);\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"onMouseDown\", function (e) {\n      var _this$props4 = _this.props,\n          draggable = _this$props4.draggable,\n          transition = _this$props4.transition;\n\n      if (e.target.nodeName === 'IMG') {\n        // Disable native browser select/drag for img elements\n        e.preventDefault();\n      }\n\n      if (draggable && transition !== 'fade' && !_this._animating) {\n        if (_this._autoplayTimer) {\n          clearTimeout(_this._autoplayTimer);\n        }\n\n        _this._startPos = {\n          x: e.clientX,\n          y: e.clientY,\n          startTime: Date.now()\n        };\n\n        _this.setState({\n          transitionDuration: 0\n        });\n\n        document.addEventListener('mousemove', _this.onMouseMove, {\n          passive: false\n        });\n        document.addEventListener('mouseup', _this.stopDragging, false);\n      }\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"onMouseMove\", function (e) {\n      e.preventDefault();\n\n      _this.setState({\n        dragOffset: e.clientX - _this._startPos.x\n      });\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"onMouseEnter\", function () {\n      document.addEventListener('mousemove', _this.handleMovement, false);\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"handleMovement\", function () {\n      _this.setHoverState(true);\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"onMouseOver\", function () {\n      _this.setHoverState(true);\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"onMouseLeave\", function () {\n      document.removeEventListener('mousemove', _this.handleMovement, false);\n\n      _this.setHoverState(false);\n\n      !_this._animating && _this._startPos && _this.stopDragging();\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"onTouchStart\", function (e) {\n      var _this$props5 = _this.props,\n          draggable = _this$props5.draggable,\n          transition = _this$props5.transition;\n\n      if (draggable && transition !== 'fade' && !_this._animating) {\n        if (_this._autoplayTimer) {\n          clearTimeout(_this._autoplayTimer);\n        }\n\n        if (e.touches.length === 1) {\n          _this._startPos = {\n            x: e.touches[0].screenX,\n            y: e.touches[0].screenY,\n            startTime: Date.now()\n          };\n          document.addEventListener('touchmove', _this.onTouchMove, {\n            passive: false\n          });\n          document.addEventListener('touchend', _this.stopDragging, false);\n        }\n      }\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"onTouchMove\", function (e) {\n      var _ref = _this._prevPos || _this._startPos,\n          x = _ref.x,\n          y = _ref.y;\n\n      var _e$touches$ = e.touches[0],\n          screenX = _e$touches$.screenX,\n          screenY = _e$touches$.screenY;\n      var angle = Math.abs(Math.atan2(screenY - y, screenX - x)) * 180 / Math.PI;\n      _this._prevPos = {\n        x: screenX,\n        y: screenY\n      };\n\n      if (angle < 20 || angle > 160) {\n        e.preventDefault();\n\n        _this.setState({\n          dragOffset: screenX - _this._startPos.x\n        });\n      }\n    });\n    (0, _defineProperty2.default)(_assertThisInitialized(_this), \"stopDragging\", function () {\n      var _this$props6 = _this.props,\n          dragThreshold = _this$props6.dragThreshold,\n          transitionDuration = _this$props6.transitionDuration;\n      var dragOffset = _this.state.dragOffset;\n      var viewportWidth = _this._viewport && _this._viewport.offsetWidth || 1;\n      var percentDragged = Math.abs(dragOffset / viewportWidth);\n      var swipeDuration = Date.now() - _this._startPos.startTime || 1;\n      var swipeSpeed = swipeDuration / (percentDragged * viewportWidth);\n      var isQuickSwipe = percentDragged > 0.05 && swipeDuration < 250;\n      var duration;\n\n      if (isQuickSwipe || percentDragged > dragThreshold) {\n        // Calculate the duration based on the speed of the swipe\n        duration = Math.min(swipeSpeed * (1 - percentDragged) * viewportWidth, (0, _ms.default)('' + transitionDuration) * (1 - percentDragged));\n      } else {\n        // Just transition back to the center point\n        duration = (0, _ms.default)('' + transitionDuration) * percentDragged;\n      }\n\n      _this.removeDragListeners();\n\n      _this.setState({\n        transitionDuration: duration\n      }, function () {\n        var _this$props7 = _this.props,\n            children = _this$props7.children,\n            infinite = _this$props7.infinite;\n        var currentSlide = _this.state.currentSlide;\n\n        var numSlides = _react.Children.count(children);\n\n        var newSlideIndex = currentSlide;\n        var direction = '';\n\n        if (percentDragged > dragThreshold || isQuickSwipe) {\n          if (dragOffset > 0) {\n            newSlideIndex--;\n\n            if (newSlideIndex < 0) {\n              newSlideIndex = infinite ? numSlides - 1 : currentSlide;\n            }\n          } else {\n            newSlideIndex++;\n\n            if (newSlideIndex === numSlides) {\n              newSlideIndex = infinite ? 0 : currentSlide;\n            }\n          }\n\n          direction = dragOffset > 0 ? 'left' : 'right';\n        }\n\n        _this.setState({\n          dragOffset: 0,\n          currentSlide: newSlideIndex,\n          direction: direction\n        });\n      });\n\n      if (_this.props.autoplay) {\n        _this.startAutoplay();\n      }\n    });\n    _this.state = {\n      currentSlide: props.initialSlide,\n      loading: props.lazyLoad,\n      loadedImages: {},\n      slideDimensions: {},\n      dragOffset: 0,\n      transitionDuration: 0,\n      transitioningFrom: null\n    };\n    return _this;\n  }\n\n  _createClass(Carousel, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this$props8 = this.props,\n          children = _this$props8.children,\n          autoplay = _this$props8.autoplay,\n          slideWidth = _this$props8.slideWidth,\n          slideAlignment = _this$props8.slideAlignment;\n      var _this$state2 = this.state,\n          currentSlide = _this$state2.currentSlide,\n          loadedImages = _this$state2.loadedImages,\n          direction = _this$state2.direction,\n          loading = _this$state2.loading,\n          slideDimensions = _this$state2.slideDimensions;\n      var oldChildren = prevProps.children;\n\n      if (direction !== prevState.direction || currentSlide !== prevState.currentSlide || loadedImages !== prevState.loadedImages || slideWidth !== prevProps.slideWidth || slideDimensions.width !== prevState.slideDimensions.width || slideDimensions.height !== prevState.slideDimensions.height || slideAlignment !== prevProps.slideAlignment) {\n        // Whenever new images are loaded, the current slide index changes, the transition direction changes, or the\n        // slide width changes, we need to recalculate the left offset positioning of the slides.\n        this.calcLeftOffset();\n      }\n\n      if (!(0, _areChildImagesEqual.default)(_react.Children.toArray(children), _react.Children.toArray(oldChildren))) {\n        // If the image source or number of images changed, we need to refetch images and force an update\n        this._animating = false;\n        this.fetchImages();\n      }\n\n      if (autoplay && (!loading && prevState.loading || !prevProps.autoplay)) {\n        this.startAutoplay();\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      var _this$props9 = this.props,\n          lazyLoad = _this$props9.lazyLoad,\n          autoplay = _this$props9.autoplay;\n      this._isMounted = true;\n\n      if (lazyLoad) {\n        this.fetchImages();\n      } else {\n        if (autoplay) {\n          this.startAutoplay();\n        }\n\n        this.calcLeftOffset();\n      }\n\n      window.addEventListener('resize', this.calcLeftOffset, false);\n\n      if (window.IntersectionObserver) {\n        this._observer = new window.IntersectionObserver(function (entries) {\n          if (!_this2.props.autoplay) {\n            return;\n          }\n\n          if (entries && entries[0] && entries[0].isIntersecting) {\n            _this2.startAutoplay();\n          } else {\n            clearTimeout(_this2._autoplayTimer);\n          }\n        });\n\n        this._observer.observe(this._containerRef);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      // Remove all event listeners\n      this.removeDragListeners();\n      window.removeEventListener('resize', this.calcLeftOffset, false);\n      document.removeEventListener('mousemove', this.handleMovement, false);\n      clearTimeout(this._autoplayTimer);\n      clearTimeout(this._retryTimer);\n      clearTimeout(this._initialLoadTimer);\n      this._observer && this._observer.unobserve(this._containerRef);\n      this._isMounted = false;\n    }\n    /**\n     * Starts the autoplay timer if it is not already running.\n     */\n\n  }, {\n    key: \"startAutoplay\",\n    value: function startAutoplay() {\n      var _this3 = this;\n\n      clearTimeout(this._autoplayTimer);\n      this._autoplayTimer = setTimeout(function () {\n        var autoplay = _this3.props.autoplay;\n\n        if (autoplay) {\n          _this3.nextSlide();\n        }\n      }, (0, _ms.default)('' + this.props.autoplaySpeed));\n    }\n    /**\n     * Loads images surrounding the specified slide index. The number of images fetched is controlled by the\n     * imagesToPrefetch prop.\n     */\n\n  }, {\n    key: \"fetchImages\",\n    value: function fetchImages() {\n      var _this4 = this;\n\n      var children = this.props.children;\n      var _this$state3 = this.state,\n          loadedImages = _this$state3.loadedImages,\n          currentSlide = _this$state3.currentSlide;\n\n      var slides = _react.Children.toArray(children);\n\n      var imagesToPrefetch = Math.min(this.props.imagesToPrefetch, slides.length);\n      var startIndex = currentSlide - Math.floor(imagesToPrefetch / 2);\n      var endIndex = startIndex + imagesToPrefetch;\n      var pendingImages = [];\n      var currentImage = slides[currentSlide].props.src;\n\n      for (var index = startIndex; index < endIndex; index++) {\n        var slide = (0, _nth.default)(slides, index % slides.length);\n        var imageSrc = slide.props.src;\n\n        if (imageSrc && !loadedImages[imageSrc]) {\n          pendingImages.push(imageSrc);\n        }\n      }\n\n      if (pendingImages.length) {\n        pendingImages.forEach(function (image) {\n          var img = new Image();\n\n          img.onload = img.onerror = function () {\n            if (_this4._isMounted) {\n              _this4.setState({\n                loadedImages: _objectSpread(_objectSpread({}, _this4.state.loadedImages), {}, _defineProperty({}, image, {\n                  width: img.width || 'auto',\n                  height: img.height || 'auto'\n                }))\n              }, function () {\n                if (image === currentImage) {\n                  _this4.handleInitialLoad();\n                }\n              });\n            }\n          };\n\n          img.src = image;\n        });\n      } else {\n        this.calcLeftOffset();\n      }\n    }\n    /**\n     * Invoked when the carousel is using lazy loading and the currently selected slide's image is first rendered. This\n     * method will clear the loading state causing the carousel to render and will calculate the dimensions of the\n     * displayed slide to use as a loading shim if an explicit width/height were not specified.\n     */\n\n    /**\n     * @returns {Array} Controls to be rendered with the carousel.\n     */\n\n  }, {\n    key: \"getControls\",\n    value: function getControls() {\n      var _this$props10 = this.props,\n          arrows = _this$props10.arrows,\n          dots = _this$props10.dots,\n          controls = _this$props10.controls;\n      var arr = controls.slice(0);\n\n      if (dots) {\n        arr.push({\n          component: _controls.Dots\n        });\n      }\n\n      if (arrows) {\n        arr = arr.concat([{\n          component: _controls.Arrow,\n          props: {\n            direction: 'left'\n          }\n        }, {\n          component: _controls.Arrow,\n          props: {\n            direction: 'right'\n          }\n        }]);\n      }\n\n      return arr;\n    }\n    /**\n     * Renders the carousel.\n     *\n     * @returns {Object} Component to be rendered.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _this$props11 = this.props,\n          className = _this$props11.className,\n          viewportWidth = _this$props11.viewportWidth,\n          viewportHeight = _this$props11.viewportHeight,\n          width = _this$props11.width,\n          height = _this$props11.height,\n          dots = _this$props11.dots,\n          infinite = _this$props11.infinite,\n          children = _this$props11.children,\n          slideHeight = _this$props11.slideHeight,\n          transition = _this$props11.transition,\n          style = _this$props11.style,\n          draggable = _this$props11.draggable,\n          easing = _this$props11.easing,\n          arrows = _this$props11.arrows;\n      var _this$state4 = this.state,\n          loading = _this$state4.loading,\n          transitionDuration = _this$state4.transitionDuration,\n          dragOffset = _this$state4.dragOffset,\n          currentSlide = _this$state4.currentSlide,\n          leftOffset = _this$state4.leftOffset;\n\n      var numSlides = _react.Children.count(children);\n\n      var classes = (0, _classnames.default)('carousel', className, {\n        loaded: !loading\n      });\n\n      var containerStyle = _objectSpread(_objectSpread({}, style.container || {}), {}, {\n        width: width,\n        height: height\n      });\n\n      var innerContainerStyle = _objectSpread(_objectSpread({}, style.containerInner || {}), {}, {\n        width: width,\n        height: height,\n        marginBottom: dots ? '20px' : 0\n      });\n\n      var viewportStyle = _objectSpread(_objectSpread({}, style.viewport || {}), {}, {\n        width: viewportWidth,\n        height: viewportHeight || slideHeight || 'auto'\n      });\n\n      var trackStyle = _objectSpread({}, style.track);\n\n      if (transition !== 'fade') {\n        var leftPos = leftOffset + dragOffset;\n        trackStyle = _objectSpread(_objectSpread({}, trackStyle), {}, {\n          transform: \"translateX(\".concat(leftPos, \"px)\"),\n          transition: transitionDuration ? \"transform \".concat((0, _ms.default)('' + transitionDuration), \"ms \").concat(easing) : 'none'\n        });\n      }\n\n      if (!draggable) {\n        trackStyle.touchAction = 'auto';\n      }\n\n      var controls = this.getControls();\n      return /*#__PURE__*/_react.default.createElement(\"div\", {\n        className: classes,\n        style: containerStyle,\n        ref: function ref(c) {\n          _this5._containerRef = c;\n        }\n      }, /*#__PURE__*/_react.default.createElement(\"div\", {\n        className: \"carousel-container-inner\",\n        style: innerContainerStyle\n      }, controls.filter(function (Control) {\n        return Control.position === 'top';\n      }).map(function (Control, index) {\n        return /*#__PURE__*/_react.default.createElement(Control.component, (0, _extends2.default)({}, Control.props, {\n          key: \"control-\".concat(index),\n          selectedIndex: currentSlide,\n          numSlides: numSlides,\n          nextSlide: _this5.nextSlide,\n          prevSlide: _this5.prevSlide,\n          goToSlide: _this5.goToSlide,\n          infinite: infinite\n        }));\n      }), /*#__PURE__*/_react.default.createElement(\"div\", {\n        className: \"carousel-viewport\",\n        ref: function ref(v) {\n          _this5._viewport = v;\n        },\n        style: viewportStyle\n      }, /*#__PURE__*/_react.default.createElement(\"ul\", {\n        className: \"carousel-track\",\n        style: trackStyle,\n        ref: function ref(t) {\n          _this5._track = t;\n        },\n        onTransitionEnd: this.slideTransitionEnd,\n        onMouseDown: this.onMouseDown,\n        onMouseLeave: this.onMouseLeave,\n        onMouseOver: this.onMouseOver,\n        onMouseEnter: this.onMouseEnter,\n        onTouchStart: this.onTouchStart\n      }, this.renderSlides())), controls.filter(function (Control) {\n        return Control.position !== 'top';\n      }).map(function (Control, index) {\n        return /*#__PURE__*/_react.default.createElement(Control.component, (0, _extends2.default)({}, Control.props, {\n          key: \"control-\".concat(index),\n          selectedIndex: currentSlide,\n          numSlides: numSlides,\n          nextSlide: _this5.nextSlide,\n          prevSlide: _this5.prevSlide,\n          goToSlide: _this5.goToSlide,\n          arrows: arrows,\n          infinite: infinite\n        }));\n      })));\n    }\n    /**\n     * Renders the slides within the carousel viewport.\n     *\n     * @returns {Array} Array of slide components to be rendered.\n     */\n\n  }, {\n    key: \"renderSlides\",\n    value: function renderSlides() {\n      var _this6 = this;\n\n      var _this$props12 = this.props,\n          children = _this$props12.children,\n          infinite = _this$props12.infinite,\n          cellPadding = _this$props12.cellPadding,\n          slideWidth = _this$props12.slideWidth,\n          slideHeight = _this$props12.slideHeight,\n          transition = _this$props12.transition,\n          transitionDuration = _this$props12.transitionDuration,\n          style = _this$props12.style,\n          easing = _this$props12.easing,\n          lazyLoad = _this$props12.lazyLoad;\n      var _this$state5 = this.state,\n          slideDimensions = _this$state5.slideDimensions,\n          currentSlide = _this$state5.currentSlide,\n          loadedImages = _this$state5.loadedImages;\n      this._allImagesLoaded = true;\n\n      var childrenToRender = _react.Children.map(children, function (child, index) {\n        var _ref2;\n\n        var key = \"slide-\".concat(index);\n        var imgSrc = child.props.src;\n        var slideClasses = (0, _classnames.default)('carousel-slide', (_ref2 = {}, _defineProperty(_ref2, SELECTED_CLASS, index === currentSlide), _defineProperty(_ref2, 'carousel-slide-fade', transition === 'fade'), _ref2));\n        var slideStyle = {\n          marginLeft: \"\".concat(cellPadding, \"px\"),\n          height: slideHeight,\n          width: slideWidth\n        };\n\n        if (transition === 'fade') {\n          slideStyle.transition = \"opacity \".concat((0, _ms.default)('' + transitionDuration), \"ms \").concat(easing);\n        }\n\n        if (slideHeight) {\n          slideStyle.overflowY = 'hidden';\n          slideStyle.minHeight = slideHeight; // Safari 9 bug\n        }\n\n        if (slideWidth) {\n          slideStyle.overflowX = 'hidden';\n          slideStyle.minWidth = slideWidth; // Safari 9 bug\n        }\n\n        slideStyle = _objectSpread(_objectSpread(_objectSpread({}, slideStyle), style.slide || {}), index === currentSlide ? style.selectedSlide || {} : {});\n\n        var loadingSlideStyle = _objectSpread(_objectSpread({}, slideStyle || {}), {}, {\n          marginLeft: slideStyle.marginLeft,\n          width: slideWidth || slideDimensions.width,\n          height: slideHeight || slideDimensions.height\n        });\n\n        var slidesToRender = _this6.getIndicesToRender(); // Only render the actual slide content if lazy loading is disabled, the image is already loaded, or we\n        // are within the configured proximity to the selected slide index.\n\n\n        if (!lazyLoad || (imgSrc ? !!loadedImages[imgSrc] : slidesToRender.indexOf(index) > -1)) {\n          // If the slide contains an image, set explicit width/height\n          if (imgSrc && loadedImages[imgSrc]) {\n            var _loadedImages$imgSrc = loadedImages[imgSrc],\n                width = _loadedImages$imgSrc.width,\n                height = _loadedImages$imgSrc.height;\n            slideStyle.height = slideStyle.height || height;\n            slideStyle.width = slideStyle.width || width;\n          }\n\n          return /*#__PURE__*/_react.default.createElement(\"li\", {\n            key: key,\n            style: slideStyle,\n            \"data-index\": index,\n            className: slideClasses,\n            onClick: _this6.handleSlideClick\n          }, child);\n        }\n\n        if (imgSrc) {\n          _this6._allImagesLoaded = false;\n        }\n\n        return /*#__PURE__*/_react.default.createElement(\"li\", {\n          key: key,\n          style: loadingSlideStyle,\n          \"data-index\": index,\n          className: (0, _classnames.default)(slideClasses, LOADING_CLASS),\n          onClick: _this6.handleSlideClick\n        });\n      });\n\n      if (infinite && transition !== 'fade') {\n        // For infinite mode, create 2 clones on each side of the track\n        childrenToRender = this.addClones(childrenToRender);\n      }\n\n      return childrenToRender;\n    }\n    /**\n     * This method returns the slides indices that should be fully rendered given the current lazyLoad and\n     * maxRenderedSlides settings.\n     *\n     * @returns {Array} Array of slide indices indicating which indices should be fully rendered.\n     */\n\n  }, {\n    key: \"getIndicesToRender\",\n    value: function getIndicesToRender() {\n      var _this$state6 = this.state,\n          currentSlide = _this$state6.currentSlide,\n          transitioningFrom = _this$state6.transitioningFrom;\n      var _this$props13 = this.props,\n          children = _this$props13.children,\n          infinite = _this$props13.infinite,\n          maxRenderedSlides = _this$props13.maxRenderedSlides;\n\n      var numSlides = _react.Children.count(children);\n\n      function genIndices(startIndex, endIndex) {\n        var indices = [];\n\n        for (var i = startIndex; i <= endIndex; i++) {\n          if (infinite && i < 0) {\n            indices.push(numSlides + i);\n          } else if (infinite && i >= numSlides) {\n            indices.push(i - numSlides);\n          } else {\n            indices.push(i);\n          }\n        }\n\n        return indices;\n      } // Figure out what slide indices need to be rendered\n\n\n      var maxSlides = Math.max(1, maxRenderedSlides);\n      var prevSlidesToRender = Math.floor((maxSlides - 1) / 2);\n      var nextSlidesToRender = Math.floor(maxSlides / 2);\n      var indices = genIndices(currentSlide - prevSlidesToRender, currentSlide + nextSlidesToRender);\n\n      if (transitioningFrom !== null) {\n        // Also render the slides around the previous slide during a transition\n        indices = indices.concat(genIndices(transitioningFrom - prevSlidesToRender, transitioningFrom + nextSlidesToRender));\n      }\n\n      return indices;\n    }\n  }, {\n    key: \"addClones\",\n    value: function addClones(originals) {\n      var numOriginals = originals.length;\n      var originalsToClone = [(0, _nth.default)(originals, numOriginals - 2), (0, _nth.default)(originals, numOriginals - 1), (0, _nth.default)(originals, 0), (0, _nth.default)(originals, Math.min(1, numOriginals - 1))];\n      var prependClones = [/*#__PURE__*/(0, _react.cloneElement)(originalsToClone[0], {\n        'key': 'clone-1',\n        'data-index': -2,\n        'className': originalsToClone[0].props.className.replace(SELECTED_CLASS, '')\n      }), /*#__PURE__*/(0, _react.cloneElement)(originalsToClone[1], {\n        'key': 'clone-0',\n        'data-index': -1,\n        'className': originalsToClone[1].props.className.replace(SELECTED_CLASS, '')\n      })];\n      var appendClones = [/*#__PURE__*/(0, _react.cloneElement)(originalsToClone[2], {\n        'key': 'clone-2',\n        'data-index': numOriginals,\n        'className': originalsToClone[2].props.className.replace(SELECTED_CLASS, '')\n      }), /*#__PURE__*/(0, _react.cloneElement)(originalsToClone[3], {\n        'key': 'clone-3',\n        'data-index': numOriginals + 1,\n        'className': originalsToClone[3].props.className.replace(SELECTED_CLASS, '')\n      })];\n      return prependClones.concat(originals).concat(appendClones);\n    }\n    /**\n     * Updates the component state with the correct left offset position so that the slides will be positioned correctly.\n     *\n     * @param {Number} retryCount Used when retries are needed due to slow slide loading\n     */\n\n    /**\n     * Keeps track of the current hover state.\n     *\n     * @param {Boolean} hovering Current hover state.\n     */\n\n  }, {\n    key: \"setHoverState\",\n    value: function setHoverState(hovering) {\n      var _this7 = this;\n\n      var _this$props14 = this.props,\n          pauseOnHover = _this$props14.pauseOnHover,\n          autoplay = _this$props14.autoplay;\n\n      if (pauseOnHover && autoplay) {\n        clearTimeout(this._hoverTimer);\n\n        if (hovering) {\n          clearTimeout(this._autoplayTimer); // If the mouse doesn't move for a few seconds, we want to restart the autoplay\n\n          this._hoverTimer = setTimeout(function () {\n            _this7.setHoverState(false);\n          }, 2000);\n        } else {\n          this.startAutoplay();\n        }\n      }\n    }\n    /**\n     * Invoked when the mouse cursor leaves a slide.\n     */\n\n    /**\n     * Removes event listeners that were added when starting a swipe operation\n     */\n\n  }, {\n    key: \"removeDragListeners\",\n    value: function removeDragListeners() {\n      document.removeEventListener('mousemove', this.onMouseMove, {\n        passive: false\n      });\n      document.removeEventListener('mouseup', this.stopDragging, false);\n      document.removeEventListener('touchmove', this.onTouchMove, {\n        passive: false\n      });\n      document.removeEventListener('touchend', this.stopDragging, false);\n    }\n    /**\n     * Completes a dragging operation, deciding whether to transition to another slide or snap back to the current slide.\n     */\n\n  }], [{\n    key: \"propTypes\",\n    get: function get() {\n      return {\n        initialSlide: _propTypes.default.number,\n        className: _propTypes.default.string,\n        transition: _propTypes.default.oneOf(['slide', 'fade']),\n        dots: _propTypes.default.bool,\n        arrows: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.shape({\n          left: _propTypes.default.node.isRequired,\n          right: _propTypes.default.node.isRequired,\n          className: _propTypes.default.string\n        })]),\n        infinite: _propTypes.default.bool,\n        children: _propTypes.default.any,\n        viewportWidth: _propTypes.default.string,\n        viewportHeight: _propTypes.default.string,\n        width: _propTypes.default.string,\n        height: _propTypes.default.string,\n        imagesToPrefetch: _propTypes.default.number,\n        maxRenderedSlides: _propTypes.default.number,\n        cellPadding: _propTypes.default.number,\n        slideWidth: _propTypes.default.string,\n        slideHeight: _propTypes.default.string,\n        slideAlignment: _propTypes.default.oneOf(['left', 'center', 'right']),\n        beforeChange: _propTypes.default.func,\n        afterChange: _propTypes.default.func,\n        transitionDuration: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n        autoplay: _propTypes.default.bool,\n        autoplaySpeed: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n        lazyLoad: _propTypes.default.bool,\n        controls: _propTypes.default.arrayOf(_propTypes.default.shape({\n          component: _propTypes.default.func.isRequired,\n          props: _propTypes.default.object,\n          position: _propTypes.default.oneOf(['top', 'bottom'])\n        })),\n        draggable: _propTypes.default.bool,\n        pauseOnHover: _propTypes.default.bool,\n        clickToNavigate: _propTypes.default.bool,\n        dragThreshold: _propTypes.default.number,\n        onSlideTransitioned: _propTypes.default.func,\n        easing: _propTypes.default.oneOf(['ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out']),\n        style: _propTypes.default.shape({\n          container: _propTypes.default.object,\n          containerInner: _propTypes.default.object,\n          viewport: _propTypes.default.object,\n          track: _propTypes.default.object,\n          slide: _propTypes.default.object,\n          selectedSlide: _propTypes.default.object\n        })\n      };\n    }\n  }, {\n    key: \"defaultProps\",\n    get: function get() {\n      return {\n        initialSlide: 0,\n        dots: true,\n        arrows: true,\n        infinite: true,\n        viewportWidth: '100%',\n        width: '100%',\n        height: 'auto',\n        imagesToPrefetch: 5,\n        maxRenderedSlides: 5,\n        cellPadding: 0,\n        slideAlignment: 'center',\n        transitionDuration: 500,\n        autoplay: false,\n        autoplaySpeed: 4000,\n        lazyLoad: true,\n        controls: [],\n        draggable: true,\n        pauseOnHover: true,\n        transition: 'slide',\n        dragThreshold: 0.2,\n        clickToNavigate: true,\n        easing: 'ease-in-out',\n        style: {}\n      };\n    }\n  }, {\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      var currentSlide = state.currentSlide;\n\n      var numChildren = _react.Children.count(props.children);\n\n      if (currentSlide >= numChildren) {\n        // The currentSlide index is no longer valid, so move to the last valid index\n        return {\n          currentSlide: numChildren ? numChildren - 1 : 0\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return Carousel;\n}(_react.Component);\n\nexports.default = Carousel;","map":{"version":3,"sources":["/workspaces/PurdueMind.github.io/mindwebsite/node_modules/react-img-carousel/lib/index.js"],"names":["_interopRequireWildcard","require","_interopRequireDefault","Object","defineProperty","exports","value","default","_extends2","_defineProperty2","_react","_propTypes","_ms","_classnames","_controls","_areChildImagesEqual","_nth","SELECTED_CLASS","LOADING_CLASS","MAX_LOAD_RETRIES","Carousel","props","arguments","currentSlide","state","slides","_track","childNodes","slideWidth","slideHeight","i","length","slide","parseInt","getAttribute","offsetWidth","offsetHeight","_initialLoadTimer","setTimeout","handleInitialLoad","setState","slideDimensions","width","height","index","direction","autoSlide","beforeChange","transitionDuration","transition","onSlideTransitioned","children","lastIndex","Children","count","newIndex","autoPlay","_animating","transitioningFrom","slideTransitionEnd","e","goToSlide","afterChange","propertyName","_allImagesLoaded","fetchImages","autoplay","startAutoplay","retryCount","loading","viewportWidth","_viewport","clearTimeout","_retryTimer","calcLeftOffset","infinite","cellPadding","slideAlignment","numChildren","leftOffset","selectedSlide","foundZeroWidthSlide","isCurrentSlideLoading","currentSlideWidth","className","indexOf","shouldRetry","bind","clickToNavigate","clickedIndex","currentTarget","Math","abs","_startPos","x","clientX","draggable","target","nodeName","preventDefault","_autoplayTimer","y","clientY","startTime","Date","now","document","addEventListener","onMouseMove","passive","stopDragging","dragOffset","handleMovement","setHoverState","removeEventListener","touches","screenX","screenY","onTouchMove","_prevPos","angle","atan2","PI","dragThreshold","percentDragged","swipeDuration","swipeSpeed","isQuickSwipe","duration","min","removeDragListeners","numSlides","newSlideIndex","initialSlide","lazyLoad","loadedImages","prevProps","prevState","oldChildren","toArray","_isMounted","window","IntersectionObserver","_observer","entries","isIntersecting","observe","_containerRef","unobserve","nextSlide","autoplaySpeed","imagesToPrefetch","startIndex","floor","endIndex","pendingImages","currentImage","src","imageSrc","push","forEach","image","img","Image","onload","onerror","arrows","dots","controls","arr","slice","component","Dots","concat","Arrow","viewportHeight","style","easing","classes","loaded","containerStyle","container","innerContainerStyle","containerInner","marginBottom","viewportStyle","viewport","trackStyle","track","leftPos","transform","touchAction","getControls","createElement","ref","c","filter","Control","position","map","key","selectedIndex","prevSlide","v","t","onTransitionEnd","onMouseDown","onMouseLeave","onMouseOver","onMouseEnter","onTouchStart","renderSlides","childrenToRender","child","imgSrc","slideClasses","slideStyle","marginLeft","overflowY","minHeight","overflowX","minWidth","loadingSlideStyle","slidesToRender","getIndicesToRender","onClick","handleSlideClick","addClones","maxRenderedSlides","genIndices","indices","maxSlides","max","prevSlidesToRender","nextSlidesToRender","originals","numOriginals","originalsToClone","prependClones","cloneElement","replace","appendClones","hovering","pauseOnHover","_hoverTimer","number","string","oneOf","bool","oneOfType","shape","left","node","isRequired","right","any","func","arrayOf","object","Component"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _ms = _interopRequireDefault(require(\"ms\"));\n\nvar _classnames = _interopRequireDefault(require(\"classnames\"));\n\nvar _controls = require(\"./controls\");\n\nvar _areChildImagesEqual = _interopRequireDefault(require(\"./utils/areChildImagesEqual\"));\n\nvar _nth = _interopRequireDefault(require(\"./utils/nth\"));\n\n/* eslint\n  jsx-a11y/mouse-events-have-key-events: 0,\n  jsx-a11y/no-noninteractive-element-interactions: 0,\n  jsx-a11y/click-events-have-key-events: 0 */\nconst SELECTED_CLASS = 'carousel-slide-selected';\nconst LOADING_CLASS = 'carousel-slide-loading';\nconst MAX_LOAD_RETRIES = 500;\n/**\n * React component class that renders a carousel, which can contain images or other content.\n *\n * @extends React.Component\n */\n\nclass Carousel extends _react.Component {\n  static get propTypes() {\n    return {\n      initialSlide: _propTypes.default.number,\n      className: _propTypes.default.string,\n      transition: _propTypes.default.oneOf(['slide', 'fade']),\n      dots: _propTypes.default.bool,\n      arrows: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.shape({\n        left: _propTypes.default.node.isRequired,\n        right: _propTypes.default.node.isRequired,\n        className: _propTypes.default.string\n      })]),\n      infinite: _propTypes.default.bool,\n      children: _propTypes.default.any,\n      viewportWidth: _propTypes.default.string,\n      viewportHeight: _propTypes.default.string,\n      width: _propTypes.default.string,\n      height: _propTypes.default.string,\n      imagesToPrefetch: _propTypes.default.number,\n      maxRenderedSlides: _propTypes.default.number,\n      cellPadding: _propTypes.default.number,\n      slideWidth: _propTypes.default.string,\n      slideHeight: _propTypes.default.string,\n      slideAlignment: _propTypes.default.oneOf(['left', 'center', 'right']),\n      beforeChange: _propTypes.default.func,\n      afterChange: _propTypes.default.func,\n      transitionDuration: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n      autoplay: _propTypes.default.bool,\n      autoplaySpeed: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),\n      lazyLoad: _propTypes.default.bool,\n      controls: _propTypes.default.arrayOf(_propTypes.default.shape({\n        component: _propTypes.default.func.isRequired,\n        props: _propTypes.default.object,\n        position: _propTypes.default.oneOf(['top', 'bottom'])\n      })),\n      draggable: _propTypes.default.bool,\n      pauseOnHover: _propTypes.default.bool,\n      clickToNavigate: _propTypes.default.bool,\n      dragThreshold: _propTypes.default.number,\n      onSlideTransitioned: _propTypes.default.func,\n      easing: _propTypes.default.oneOf(['ease', 'linear', 'ease-in', 'ease-out', 'ease-in-out']),\n      style: _propTypes.default.shape({\n        container: _propTypes.default.object,\n        containerInner: _propTypes.default.object,\n        viewport: _propTypes.default.object,\n        track: _propTypes.default.object,\n        slide: _propTypes.default.object,\n        selectedSlide: _propTypes.default.object\n      })\n    };\n  }\n\n  static get defaultProps() {\n    return {\n      initialSlide: 0,\n      dots: true,\n      arrows: true,\n      infinite: true,\n      viewportWidth: '100%',\n      width: '100%',\n      height: 'auto',\n      imagesToPrefetch: 5,\n      maxRenderedSlides: 5,\n      cellPadding: 0,\n      slideAlignment: 'center',\n      transitionDuration: 500,\n      autoplay: false,\n      autoplaySpeed: 4000,\n      lazyLoad: true,\n      controls: [],\n      draggable: true,\n      pauseOnHover: true,\n      transition: 'slide',\n      dragThreshold: 0.2,\n      clickToNavigate: true,\n      easing: 'ease-in-out',\n      style: {}\n    };\n  }\n\n  constructor(props) {\n    super(...arguments);\n    (0, _defineProperty2.default)(this, \"handleInitialLoad\", () => {\n      const {\n        currentSlide\n      } = this.state;\n      const slides = this._track.childNodes;\n      const {\n        slideWidth,\n        slideHeight\n      } = this.props;\n\n      if (!slideWidth || !slideHeight) {\n        for (let i = 0; i < slides.length; i++) {\n          const slide = slides[i];\n\n          if (parseInt(slide.getAttribute('data-index'), 10) === currentSlide) {\n            if (!slide.offsetWidth || !slide.offsetHeight) {\n              this._initialLoadTimer = setTimeout(this.handleInitialLoad, 10);\n              return;\n            }\n\n            this.setState({\n              slideDimensions: {\n                width: slide.offsetWidth,\n                height: slide.offsetHeight\n              }\n            });\n            break;\n          }\n        }\n      }\n    });\n    (0, _defineProperty2.default)(this, \"goToSlide\", (index, direction, autoSlide = false) => {\n      const {\n        beforeChange,\n        transitionDuration,\n        transition,\n        onSlideTransitioned,\n        children\n      } = this.props;\n      const {\n        currentSlide\n      } = this.state;\n      const lastIndex = _react.Children.count(children) - 1;\n      const newIndex = index < 0 ? lastIndex + index + 1 : index <= lastIndex ? index : index - lastIndex - 1;\n      direction = direction || (index > currentSlide ? 'right' : 'left');\n\n      if (onSlideTransitioned) {\n        onSlideTransitioned({\n          autoPlay: autoSlide,\n          index: newIndex,\n          direction\n        });\n      }\n\n      if (currentSlide === newIndex) {\n        return;\n      }\n\n      if (this._animating) {\n        return;\n      }\n\n      this._animating = true;\n      beforeChange && beforeChange(newIndex, currentSlide, direction);\n      this.setState({\n        transitionDuration\n      }, () => {\n        this.setState({\n          currentSlide: newIndex,\n          direction,\n          transitioningFrom: currentSlide\n        }, () => {\n          if (!transitionDuration || transition === 'fade') {\n            // We don't actually animate if transitionDuration is 0, so immediately call the transition end callback\n            this.slideTransitionEnd();\n          }\n        });\n      });\n    });\n    (0, _defineProperty2.default)(this, \"nextSlide\", e => {\n      const {\n        currentSlide\n      } = this.state;\n      this.goToSlide(currentSlide + 1, 'right', typeof e !== 'object');\n    });\n    (0, _defineProperty2.default)(this, \"prevSlide\", () => {\n      const {\n        currentSlide\n      } = this.state;\n      this.goToSlide(currentSlide - 1, 'left');\n    });\n    (0, _defineProperty2.default)(this, \"slideTransitionEnd\", e => {\n      const {\n        currentSlide\n      } = this.state;\n      const {\n        afterChange\n      } = this.props;\n\n      if (!e || e.propertyName === 'transform') {\n        this._animating = false;\n        this.setState({\n          direction: null,\n          transitioningFrom: null,\n          transitionDuration: 0\n        }, () => {\n          if (!this._allImagesLoaded) {\n            this.fetchImages();\n          }\n        });\n\n        if (this.props.autoplay) {\n          this.startAutoplay();\n        }\n\n        afterChange && afterChange(currentSlide);\n      }\n    });\n    (0, _defineProperty2.default)(this, \"calcLeftOffset\", (retryCount = 0) => {\n      const {\n        direction,\n        loading\n      } = this.state;\n      const viewportWidth = this._viewport && this._viewport.offsetWidth;\n      clearTimeout(this._retryTimer);\n\n      if (!this._track || !viewportWidth) {\n        this._retryTimer = setTimeout(this.calcLeftOffset, 10);\n        return;\n      }\n\n      const {\n        infinite,\n        children,\n        cellPadding,\n        slideAlignment\n      } = this.props;\n      let {\n        currentSlide\n      } = this.state;\n      const slides = this._track.childNodes;\n\n      const numChildren = _react.Children.count(children);\n\n      if (infinite) {\n        if (currentSlide === 0 && direction === 'right') {\n          currentSlide = numChildren;\n        } else if (currentSlide === numChildren - 1 && direction === 'left') {\n          currentSlide = -1;\n        }\n      }\n\n      let leftOffset = 0;\n      let selectedSlide;\n      let foundZeroWidthSlide = false;\n      let isCurrentSlideLoading = false;\n      let currentSlideWidth;\n\n      for (let i = 0; i < slides.length; i++) {\n        selectedSlide = slides[i];\n        leftOffset -= cellPadding;\n        isCurrentSlideLoading = selectedSlide.className.indexOf(LOADING_CLASS) !== -1;\n        currentSlideWidth = selectedSlide.offsetWidth;\n        foundZeroWidthSlide = foundZeroWidthSlide || !currentSlideWidth && !isCurrentSlideLoading;\n\n        if (parseInt(selectedSlide.getAttribute('data-index'), 10) === currentSlide) {\n          break;\n        }\n\n        leftOffset -= currentSlideWidth;\n      } // Adjust the offset to get the correct alignment of current slide within the viewport\n\n\n      if (slideAlignment === 'center') {\n        leftOffset += (viewportWidth - currentSlideWidth) / 2;\n      } else if (slideAlignment === 'right') {\n        leftOffset += viewportWidth - currentSlideWidth;\n      }\n\n      const shouldRetry = foundZeroWidthSlide && retryCount < MAX_LOAD_RETRIES;\n\n      if (leftOffset !== this.state.leftOffset) {\n        this.setState({\n          leftOffset\n        });\n      }\n\n      if (shouldRetry) {\n        this._retryTimer = setTimeout(this.calcLeftOffset.bind(this, ++retryCount), 10);\n        return;\n      }\n\n      if (loading) {\n        // We have correctly positioned the slides and are done loading images, so reveal the carousel\n        this.setState({\n          loading: false\n        });\n      }\n    });\n    (0, _defineProperty2.default)(this, \"handleSlideClick\", e => {\n      const {\n        clickToNavigate\n      } = this.props;\n      const {\n        currentSlide\n      } = this.state;\n      const clickedIndex = parseInt(e.currentTarget.getAttribute('data-index'), 10); // If the user clicked the current slide or it appears they are dragging, don't process the click\n\n      if (!clickToNavigate || clickedIndex === currentSlide || Math.abs(this._startPos.x - e.clientX) > 0.01) {\n        return;\n      }\n\n      this.goToSlide(clickedIndex);\n    });\n    (0, _defineProperty2.default)(this, \"onMouseDown\", e => {\n      const {\n        draggable,\n        transition\n      } = this.props;\n\n      if (e.target.nodeName === 'IMG') {\n        // Disable native browser select/drag for img elements\n        e.preventDefault();\n      }\n\n      if (draggable && transition !== 'fade' && !this._animating) {\n        if (this._autoplayTimer) {\n          clearTimeout(this._autoplayTimer);\n        }\n\n        this._startPos = {\n          x: e.clientX,\n          y: e.clientY,\n          startTime: Date.now()\n        };\n        this.setState({\n          transitionDuration: 0\n        });\n        document.addEventListener('mousemove', this.onMouseMove, {\n          passive: false\n        });\n        document.addEventListener('mouseup', this.stopDragging, false);\n      }\n    });\n    (0, _defineProperty2.default)(this, \"onMouseMove\", e => {\n      e.preventDefault();\n      this.setState({\n        dragOffset: e.clientX - this._startPos.x\n      });\n    });\n    (0, _defineProperty2.default)(this, \"onMouseEnter\", () => {\n      document.addEventListener('mousemove', this.handleMovement, false);\n    });\n    (0, _defineProperty2.default)(this, \"handleMovement\", () => {\n      this.setHoverState(true);\n    });\n    (0, _defineProperty2.default)(this, \"onMouseOver\", () => {\n      this.setHoverState(true);\n    });\n    (0, _defineProperty2.default)(this, \"onMouseLeave\", () => {\n      document.removeEventListener('mousemove', this.handleMovement, false);\n      this.setHoverState(false);\n      !this._animating && this._startPos && this.stopDragging();\n    });\n    (0, _defineProperty2.default)(this, \"onTouchStart\", e => {\n      const {\n        draggable,\n        transition\n      } = this.props;\n\n      if (draggable && transition !== 'fade' && !this._animating) {\n        if (this._autoplayTimer) {\n          clearTimeout(this._autoplayTimer);\n        }\n\n        if (e.touches.length === 1) {\n          this._startPos = {\n            x: e.touches[0].screenX,\n            y: e.touches[0].screenY,\n            startTime: Date.now()\n          };\n          document.addEventListener('touchmove', this.onTouchMove, {\n            passive: false\n          });\n          document.addEventListener('touchend', this.stopDragging, false);\n        }\n      }\n    });\n    (0, _defineProperty2.default)(this, \"onTouchMove\", e => {\n      const {\n        x,\n        y\n      } = this._prevPos || this._startPos;\n      const {\n        screenX,\n        screenY\n      } = e.touches[0];\n      const angle = Math.abs(Math.atan2(screenY - y, screenX - x)) * 180 / Math.PI;\n      this._prevPos = {\n        x: screenX,\n        y: screenY\n      };\n\n      if (angle < 20 || angle > 160) {\n        e.preventDefault();\n        this.setState({\n          dragOffset: screenX - this._startPos.x\n        });\n      }\n    });\n    (0, _defineProperty2.default)(this, \"stopDragging\", () => {\n      const {\n        dragThreshold,\n        transitionDuration\n      } = this.props;\n      const {\n        dragOffset\n      } = this.state;\n      const viewportWidth = this._viewport && this._viewport.offsetWidth || 1;\n      const percentDragged = Math.abs(dragOffset / viewportWidth);\n      const swipeDuration = Date.now() - this._startPos.startTime || 1;\n      const swipeSpeed = swipeDuration / (percentDragged * viewportWidth);\n      const isQuickSwipe = percentDragged > 0.05 && swipeDuration < 250;\n      let duration;\n\n      if (isQuickSwipe || percentDragged > dragThreshold) {\n        // Calculate the duration based on the speed of the swipe\n        duration = Math.min(swipeSpeed * (1 - percentDragged) * viewportWidth, (0, _ms.default)('' + transitionDuration) * (1 - percentDragged));\n      } else {\n        // Just transition back to the center point\n        duration = (0, _ms.default)('' + transitionDuration) * percentDragged;\n      }\n\n      this.removeDragListeners();\n      this.setState({\n        transitionDuration: duration\n      }, () => {\n        const {\n          children,\n          infinite\n        } = this.props;\n        const {\n          currentSlide\n        } = this.state;\n\n        const numSlides = _react.Children.count(children);\n\n        let newSlideIndex = currentSlide;\n        let direction = '';\n\n        if (percentDragged > dragThreshold || isQuickSwipe) {\n          if (dragOffset > 0) {\n            newSlideIndex--;\n\n            if (newSlideIndex < 0) {\n              newSlideIndex = infinite ? numSlides - 1 : currentSlide;\n            }\n          } else {\n            newSlideIndex++;\n\n            if (newSlideIndex === numSlides) {\n              newSlideIndex = infinite ? 0 : currentSlide;\n            }\n          }\n\n          direction = dragOffset > 0 ? 'left' : 'right';\n        }\n\n        this.setState({\n          dragOffset: 0,\n          currentSlide: newSlideIndex,\n          direction\n        });\n      });\n\n      if (this.props.autoplay) {\n        this.startAutoplay();\n      }\n    });\n    this.state = {\n      currentSlide: props.initialSlide,\n      loading: props.lazyLoad,\n      loadedImages: {},\n      slideDimensions: {},\n      dragOffset: 0,\n      transitionDuration: 0,\n      transitioningFrom: null\n    };\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    const {\n      currentSlide\n    } = state;\n\n    const numChildren = _react.Children.count(props.children);\n\n    if (currentSlide >= numChildren) {\n      // The currentSlide index is no longer valid, so move to the last valid index\n      return {\n        currentSlide: numChildren ? numChildren - 1 : 0\n      };\n    }\n\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      children,\n      autoplay,\n      slideWidth,\n      slideAlignment\n    } = this.props;\n    const {\n      currentSlide,\n      loadedImages,\n      direction,\n      loading,\n      slideDimensions\n    } = this.state;\n    const oldChildren = prevProps.children;\n\n    if (direction !== prevState.direction || currentSlide !== prevState.currentSlide || loadedImages !== prevState.loadedImages || slideWidth !== prevProps.slideWidth || slideDimensions.width !== prevState.slideDimensions.width || slideDimensions.height !== prevState.slideDimensions.height || slideAlignment !== prevProps.slideAlignment) {\n      // Whenever new images are loaded, the current slide index changes, the transition direction changes, or the\n      // slide width changes, we need to recalculate the left offset positioning of the slides.\n      this.calcLeftOffset();\n    }\n\n    if (!(0, _areChildImagesEqual.default)(_react.Children.toArray(children), _react.Children.toArray(oldChildren))) {\n      // If the image source or number of images changed, we need to refetch images and force an update\n      this._animating = false;\n      this.fetchImages();\n    }\n\n    if (autoplay && (!loading && prevState.loading || !prevProps.autoplay)) {\n      this.startAutoplay();\n    }\n  }\n\n  componentDidMount() {\n    const {\n      lazyLoad,\n      autoplay\n    } = this.props;\n    this._isMounted = true;\n\n    if (lazyLoad) {\n      this.fetchImages();\n    } else {\n      if (autoplay) {\n        this.startAutoplay();\n      }\n\n      this.calcLeftOffset();\n    }\n\n    window.addEventListener('resize', this.calcLeftOffset, false);\n\n    if (window.IntersectionObserver) {\n      this._observer = new window.IntersectionObserver(entries => {\n        if (!this.props.autoplay) {\n          return;\n        }\n\n        if (entries && entries[0] && entries[0].isIntersecting) {\n          this.startAutoplay();\n        } else {\n          clearTimeout(this._autoplayTimer);\n        }\n      });\n\n      this._observer.observe(this._containerRef);\n    }\n  }\n\n  componentWillUnmount() {\n    // Remove all event listeners\n    this.removeDragListeners();\n    window.removeEventListener('resize', this.calcLeftOffset, false);\n    document.removeEventListener('mousemove', this.handleMovement, false);\n    clearTimeout(this._autoplayTimer);\n    clearTimeout(this._retryTimer);\n    clearTimeout(this._initialLoadTimer);\n    this._observer && this._observer.unobserve(this._containerRef);\n    this._isMounted = false;\n  }\n  /**\n   * Starts the autoplay timer if it is not already running.\n   */\n\n\n  startAutoplay() {\n    clearTimeout(this._autoplayTimer);\n    this._autoplayTimer = setTimeout(() => {\n      const {\n        autoplay\n      } = this.props;\n\n      if (autoplay) {\n        this.nextSlide();\n      }\n    }, (0, _ms.default)('' + this.props.autoplaySpeed));\n  }\n  /**\n   * Loads images surrounding the specified slide index. The number of images fetched is controlled by the\n   * imagesToPrefetch prop.\n   */\n\n\n  fetchImages() {\n    const {\n      children\n    } = this.props;\n    const {\n      loadedImages,\n      currentSlide\n    } = this.state;\n\n    const slides = _react.Children.toArray(children);\n\n    const imagesToPrefetch = Math.min(this.props.imagesToPrefetch, slides.length);\n    const startIndex = currentSlide - Math.floor(imagesToPrefetch / 2);\n    const endIndex = startIndex + imagesToPrefetch;\n    const pendingImages = [];\n    const currentImage = slides[currentSlide].props.src;\n\n    for (let index = startIndex; index < endIndex; index++) {\n      const slide = (0, _nth.default)(slides, index % slides.length);\n      const imageSrc = slide.props.src;\n\n      if (imageSrc && !loadedImages[imageSrc]) {\n        pendingImages.push(imageSrc);\n      }\n    }\n\n    if (pendingImages.length) {\n      pendingImages.forEach(image => {\n        const img = new Image();\n\n        img.onload = img.onerror = () => {\n          if (this._isMounted) {\n            this.setState({\n              loadedImages: { ...this.state.loadedImages,\n                [image]: {\n                  width: img.width || 'auto',\n                  height: img.height || 'auto'\n                }\n              }\n            }, () => {\n              if (image === currentImage) {\n                this.handleInitialLoad();\n              }\n            });\n          }\n        };\n\n        img.src = image;\n      });\n    } else {\n      this.calcLeftOffset();\n    }\n  }\n  /**\n   * Invoked when the carousel is using lazy loading and the currently selected slide's image is first rendered. This\n   * method will clear the loading state causing the carousel to render and will calculate the dimensions of the\n   * displayed slide to use as a loading shim if an explicit width/height were not specified.\n   */\n\n\n  /**\n   * @returns {Array} Controls to be rendered with the carousel.\n   */\n  getControls() {\n    const {\n      arrows,\n      dots,\n      controls\n    } = this.props;\n    let arr = controls.slice(0);\n\n    if (dots) {\n      arr.push({\n        component: _controls.Dots\n      });\n    }\n\n    if (arrows) {\n      arr = arr.concat([{\n        component: _controls.Arrow,\n        props: {\n          direction: 'left'\n        }\n      }, {\n        component: _controls.Arrow,\n        props: {\n          direction: 'right'\n        }\n      }]);\n    }\n\n    return arr;\n  }\n  /**\n   * Renders the carousel.\n   *\n   * @returns {Object} Component to be rendered.\n   */\n\n\n  render() {\n    const {\n      className,\n      viewportWidth,\n      viewportHeight,\n      width,\n      height,\n      dots,\n      infinite,\n      children,\n      slideHeight,\n      transition,\n      style,\n      draggable,\n      easing,\n      arrows\n    } = this.props;\n    const {\n      loading,\n      transitionDuration,\n      dragOffset,\n      currentSlide,\n      leftOffset\n    } = this.state;\n\n    const numSlides = _react.Children.count(children);\n\n    const classes = (0, _classnames.default)('carousel', className, {\n      loaded: !loading\n    });\n    const containerStyle = { ...(style.container || {}),\n      width,\n      height\n    };\n    const innerContainerStyle = { ...(style.containerInner || {}),\n      width,\n      height,\n      marginBottom: dots ? '20px' : 0\n    };\n    const viewportStyle = { ...(style.viewport || {}),\n      width: viewportWidth,\n      height: viewportHeight || slideHeight || 'auto'\n    };\n    let trackStyle = { ...style.track\n    };\n\n    if (transition !== 'fade') {\n      const leftPos = leftOffset + dragOffset;\n      trackStyle = { ...trackStyle,\n        transform: `translateX(${leftPos}px)`,\n        transition: transitionDuration ? `transform ${(0, _ms.default)('' + transitionDuration)}ms ${easing}` : 'none'\n      };\n    }\n\n    if (!draggable) {\n      trackStyle.touchAction = 'auto';\n    }\n\n    const controls = this.getControls();\n    return /*#__PURE__*/_react.default.createElement(\"div\", {\n      className: classes,\n      style: containerStyle,\n      ref: c => {\n        this._containerRef = c;\n      }\n    }, /*#__PURE__*/_react.default.createElement(\"div\", {\n      className: \"carousel-container-inner\",\n      style: innerContainerStyle\n    }, controls.filter(Control => {\n      return Control.position === 'top';\n    }).map((Control, index) => /*#__PURE__*/_react.default.createElement(Control.component, (0, _extends2.default)({}, Control.props, {\n      key: `control-${index}`,\n      selectedIndex: currentSlide,\n      numSlides: numSlides,\n      nextSlide: this.nextSlide,\n      prevSlide: this.prevSlide,\n      goToSlide: this.goToSlide,\n      infinite: infinite\n    }))), /*#__PURE__*/_react.default.createElement(\"div\", {\n      className: \"carousel-viewport\",\n      ref: v => {\n        this._viewport = v;\n      },\n      style: viewportStyle\n    }, /*#__PURE__*/_react.default.createElement(\"ul\", {\n      className: \"carousel-track\",\n      style: trackStyle,\n      ref: t => {\n        this._track = t;\n      },\n      onTransitionEnd: this.slideTransitionEnd,\n      onMouseDown: this.onMouseDown,\n      onMouseLeave: this.onMouseLeave,\n      onMouseOver: this.onMouseOver,\n      onMouseEnter: this.onMouseEnter,\n      onTouchStart: this.onTouchStart\n    }, this.renderSlides())), controls.filter(Control => {\n      return Control.position !== 'top';\n    }).map((Control, index) => /*#__PURE__*/_react.default.createElement(Control.component, (0, _extends2.default)({}, Control.props, {\n      key: `control-${index}`,\n      selectedIndex: currentSlide,\n      numSlides: numSlides,\n      nextSlide: this.nextSlide,\n      prevSlide: this.prevSlide,\n      goToSlide: this.goToSlide,\n      arrows: arrows,\n      infinite: infinite\n    })))));\n  }\n  /**\n   * Renders the slides within the carousel viewport.\n   *\n   * @returns {Array} Array of slide components to be rendered.\n   */\n\n\n  renderSlides() {\n    const {\n      children,\n      infinite,\n      cellPadding,\n      slideWidth,\n      slideHeight,\n      transition,\n      transitionDuration,\n      style,\n      easing,\n      lazyLoad\n    } = this.props;\n    const {\n      slideDimensions,\n      currentSlide,\n      loadedImages\n    } = this.state;\n    this._allImagesLoaded = true;\n\n    let childrenToRender = _react.Children.map(children, (child, index) => {\n      const key = `slide-${index}`;\n      const imgSrc = child.props.src;\n      const slideClasses = (0, _classnames.default)('carousel-slide', {\n        [SELECTED_CLASS]: index === currentSlide,\n        'carousel-slide-fade': transition === 'fade'\n      });\n      let slideStyle = {\n        marginLeft: `${cellPadding}px`,\n        height: slideHeight,\n        width: slideWidth\n      };\n\n      if (transition === 'fade') {\n        slideStyle.transition = `opacity ${(0, _ms.default)('' + transitionDuration)}ms ${easing}`;\n      }\n\n      if (slideHeight) {\n        slideStyle.overflowY = 'hidden';\n        slideStyle.minHeight = slideHeight; // Safari 9 bug\n      }\n\n      if (slideWidth) {\n        slideStyle.overflowX = 'hidden';\n        slideStyle.minWidth = slideWidth; // Safari 9 bug\n      }\n\n      slideStyle = { ...slideStyle,\n        ...(style.slide || {}),\n        ...(index === currentSlide ? style.selectedSlide || {} : {})\n      };\n      const loadingSlideStyle = { ...(slideStyle || {}),\n        marginLeft: slideStyle.marginLeft,\n        width: slideWidth || slideDimensions.width,\n        height: slideHeight || slideDimensions.height\n      };\n      const slidesToRender = this.getIndicesToRender(); // Only render the actual slide content if lazy loading is disabled, the image is already loaded, or we\n      // are within the configured proximity to the selected slide index.\n\n      if (!lazyLoad || (imgSrc ? !!loadedImages[imgSrc] : slidesToRender.indexOf(index) > -1)) {\n        // If the slide contains an image, set explicit width/height\n        if (imgSrc && loadedImages[imgSrc]) {\n          const {\n            width,\n            height\n          } = loadedImages[imgSrc];\n          slideStyle.height = slideStyle.height || height;\n          slideStyle.width = slideStyle.width || width;\n        }\n\n        return /*#__PURE__*/_react.default.createElement(\"li\", {\n          key: key,\n          style: slideStyle,\n          \"data-index\": index,\n          className: slideClasses,\n          onClick: this.handleSlideClick\n        }, child);\n      }\n\n      if (imgSrc) {\n        this._allImagesLoaded = false;\n      }\n\n      return /*#__PURE__*/_react.default.createElement(\"li\", {\n        key: key,\n        style: loadingSlideStyle,\n        \"data-index\": index,\n        className: (0, _classnames.default)(slideClasses, LOADING_CLASS),\n        onClick: this.handleSlideClick\n      });\n    });\n\n    if (infinite && transition !== 'fade') {\n      // For infinite mode, create 2 clones on each side of the track\n      childrenToRender = this.addClones(childrenToRender);\n    }\n\n    return childrenToRender;\n  }\n  /**\n   * This method returns the slides indices that should be fully rendered given the current lazyLoad and\n   * maxRenderedSlides settings.\n   *\n   * @returns {Array} Array of slide indices indicating which indices should be fully rendered.\n   */\n\n\n  getIndicesToRender() {\n    const {\n      currentSlide,\n      transitioningFrom\n    } = this.state;\n    const {\n      children,\n      infinite,\n      maxRenderedSlides\n    } = this.props;\n\n    const numSlides = _react.Children.count(children);\n\n    function genIndices(startIndex, endIndex) {\n      const indices = [];\n\n      for (let i = startIndex; i <= endIndex; i++) {\n        if (infinite && i < 0) {\n          indices.push(numSlides + i);\n        } else if (infinite && i >= numSlides) {\n          indices.push(i - numSlides);\n        } else {\n          indices.push(i);\n        }\n      }\n\n      return indices;\n    } // Figure out what slide indices need to be rendered\n\n\n    const maxSlides = Math.max(1, maxRenderedSlides);\n    const prevSlidesToRender = Math.floor((maxSlides - 1) / 2);\n    const nextSlidesToRender = Math.floor(maxSlides / 2);\n    let indices = genIndices(currentSlide - prevSlidesToRender, currentSlide + nextSlidesToRender);\n\n    if (transitioningFrom !== null) {\n      // Also render the slides around the previous slide during a transition\n      indices = indices.concat(genIndices(transitioningFrom - prevSlidesToRender, transitioningFrom + nextSlidesToRender));\n    }\n\n    return indices;\n  }\n\n  addClones(originals) {\n    const numOriginals = originals.length;\n    const originalsToClone = [(0, _nth.default)(originals, numOriginals - 2), (0, _nth.default)(originals, numOriginals - 1), (0, _nth.default)(originals, 0), (0, _nth.default)(originals, Math.min(1, numOriginals - 1))];\n    const prependClones = [/*#__PURE__*/(0, _react.cloneElement)(originalsToClone[0], {\n      'key': 'clone-1',\n      'data-index': -2,\n      'className': originalsToClone[0].props.className.replace(SELECTED_CLASS, '')\n    }), /*#__PURE__*/(0, _react.cloneElement)(originalsToClone[1], {\n      'key': 'clone-0',\n      'data-index': -1,\n      'className': originalsToClone[1].props.className.replace(SELECTED_CLASS, '')\n    })];\n    const appendClones = [/*#__PURE__*/(0, _react.cloneElement)(originalsToClone[2], {\n      'key': 'clone-2',\n      'data-index': numOriginals,\n      'className': originalsToClone[2].props.className.replace(SELECTED_CLASS, '')\n    }), /*#__PURE__*/(0, _react.cloneElement)(originalsToClone[3], {\n      'key': 'clone-3',\n      'data-index': numOriginals + 1,\n      'className': originalsToClone[3].props.className.replace(SELECTED_CLASS, '')\n    })];\n    return prependClones.concat(originals).concat(appendClones);\n  }\n  /**\n   * Updates the component state with the correct left offset position so that the slides will be positioned correctly.\n   *\n   * @param {Number} retryCount Used when retries are needed due to slow slide loading\n   */\n\n\n  /**\n   * Keeps track of the current hover state.\n   *\n   * @param {Boolean} hovering Current hover state.\n   */\n  setHoverState(hovering) {\n    const {\n      pauseOnHover,\n      autoplay\n    } = this.props;\n\n    if (pauseOnHover && autoplay) {\n      clearTimeout(this._hoverTimer);\n\n      if (hovering) {\n        clearTimeout(this._autoplayTimer); // If the mouse doesn't move for a few seconds, we want to restart the autoplay\n\n        this._hoverTimer = setTimeout(() => {\n          this.setHoverState(false);\n        }, 2000);\n      } else {\n        this.startAutoplay();\n      }\n    }\n  }\n  /**\n   * Invoked when the mouse cursor leaves a slide.\n   */\n\n\n  /**\n   * Removes event listeners that were added when starting a swipe operation\n   */\n  removeDragListeners() {\n    document.removeEventListener('mousemove', this.onMouseMove, {\n      passive: false\n    });\n    document.removeEventListener('mouseup', this.stopDragging, false);\n    document.removeEventListener('touchmove', this.onTouchMove, {\n      passive: false\n    });\n    document.removeEventListener('touchend', this.stopDragging, false);\n  }\n  /**\n   * Completes a dragging operation, deciding whether to transition to another slide or snap back to the current slide.\n   */\n\n\n}\n\nexports.default = Carousel;"]},"metadata":{},"sourceType":"script"}